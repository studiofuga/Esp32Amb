#include "sdkconfig.h" // generated by "make menuconfig"
#include "config.h"

#include "gattserver.h"
#include "driver/i2c.h"

#include "if_bme280.h"
#include "ccs811.h"
#include "bme280.h"

#include "esp_err.h"
#include "esp_log.h"

#define TAG_BME280 "BME280"
#define I2C_BUS       0

static ccs811_sensor_t* sensor;

struct bme280_t bme280 = {
	.bus_write = BME280_I2C_bus_write,
	.bus_read = BME280_I2C_bus_read,
	.dev_addr = BME280_I2C_ADDRESS2,
	.delay_msec = BME280_delay_msek
};

s32 com_rslt;
s32 v_uncomp_pressure_s32;
s32 v_uncomp_temperature_s32;
s32 v_uncomp_humidity_s32;
uint16_t tvoc;
uint16_t eco2;

void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = I2C_FREQ_100K
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}

void init_ccs_task ()
{
}

int init_bme_task()
{

	com_rslt = bme280_init(&bme280);

	com_rslt += bme280_set_oversamp_pressure(BME280_OVERSAMP_16X);
	com_rslt += bme280_set_oversamp_temperature(BME280_OVERSAMP_2X);
	com_rslt += bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);

	com_rslt += bme280_set_standby_durn(BME280_STANDBY_TIME_1_MS);
	com_rslt += bme280_set_filter(BME280_FILTER_COEFF_16);

	com_rslt += bme280_set_power_mode(BME280_NORMAL_MODE);
	
	if (com_rslt == SUCCESS)
		return 0;
	else {
		ESP_LOGE(TAG_BME280, "init or setting error. code: %d", com_rslt);
		return -1;
	}
}

void poll_bme()
{
	com_rslt = bme280_read_uncomp_pressure_temperature_humidity(
		&v_uncomp_pressure_s32, &v_uncomp_temperature_s32, &v_uncomp_humidity_s32);

	if (com_rslt == SUCCESS) {
		ESP_LOGI(TAG_BME280, "%.2f degC / %.3f hPa / %.3f %%",
			bme280_compensate_temperature_double(v_uncomp_temperature_s32),
			bme280_compensate_pressure_double(v_uncomp_pressure_s32)/100, // Pa -> hPa
			bme280_compensate_humidity_double(v_uncomp_humidity_s32));
	} else {
		ESP_LOGE(TAG_BME280, "measure error. code: %d", com_rslt);
	}
}

void poll_ccs()
{
	if (ccs811_get_results (sensor, &tvoc, &eco2, 0, 0))
		printf("%.3f CCS811 Sensor periodic: TVOC %d ppb, eCO2 %d ppm\n",
			   (double)sdk_system_get_time()*1e-3, tvoc, eco2);
			   else
		ESP_LOGE(TAG_BME280, "CCS measure error.");
			   
}

void task_poll(void *ignore)
{
	init_bme_task();
	init_ccs_task();
	
	if (com_rslt == SUCCESS) {
	    TickType_t last_wakeup = xTaskGetTickCount();

		while(true) {
			//vTaskDelay(40/portTICK_PERIOD_MS);
			poll_bme();
			poll_ccs();
			// passive waiting until 1 second is over
			vTaskDelayUntil(&last_wakeup, 1000 / portTICK_PERIOD_MS);
		}
	} else {
	}

	vTaskDelete(NULL);
}

void app_main(void)
{
	i2c_master_init();
	
    // longer clock stretching is required for CCS811
    i2c_set_clock_stretch (I2C_BUS, CCS811_I2C_CLOCK_STRETCH);

	// init the sensor with slave address CCS811_I2C_ADDRESS_1 connected I2C_BUS.
    sensor = ccs811_init_sensor (I2C_BUS, CCS811_I2C_ADDRESS_2);

	gattserver_init();

	xTaskCreate(&task_poll, "poll_task",  2048, NULL, 6, NULL);
	//xTaskCreate(user_task_periodic, "user_task_periodic", TASK_STACK_DEPTH, NULL, 2, NULL);
}

